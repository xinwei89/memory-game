// Test setup for jsdom environment
// Mock DOM elements that the MemoryGame class expects

// Mock the HTML structure that MemoryGame expects
document.body.innerHTML = `
<div class="game-container">
    <div class="game-header">
        <h1>Memory Game</h1>
        <div class="game-controls">
            <label for="grid-size">Grid Size:</label>
            <select id="grid-size" class="grid-selector">
                <option value="2">2x2 (2 pairs)</option>
                <option value="4">4x4 (8 pairs)</option>
                <option value="6">6x6 (18 pairs)</option>
                <option value="8">8x8 (32 pairs)</option>
            </select>
            <button id="start-btn" class="start-btn">Start Game</button>
        </div>
        <div class="game-stats" id="game-stats" style="display: none;">
            <div class="stat">
                <span>Moves: </span>
                <span id="moves">0</span>
            </div>
            <div class="stat">
                <span>Time: </span>
                <span id="timer">00:00</span>
            </div>
            <div class="stat">
                <span>Pairs: </span>
                <span id="pairs">0/2</span>
            </div>
        </div>
        <button id="restart-btn" class="restart-btn" style="display: none;">Restart Game</button>
    </div>
    <div class="game-board" id="game-board">
        <!-- Cards will be generated by JavaScript -->
    </div>
    <div class="game-message" id="game-message"></div>
</div>
`;

// Mock console methods to avoid noise in tests
global.console = {
    ...console,
    // Suppress console.log during tests but keep error and warn
    log: jest.fn(),
};

// Mock Image constructor for card images
global.Image = class {
    constructor() {
        setTimeout(() => {
            if (this.onload) this.onload();
        }, 0);
    }
    set src(value) {
        this._src = value;
    }
    get src() {
        return this._src;
    }
};

// Mock Date.now for consistent timing tests
const mockDateNow = jest.spyOn(Date, 'now');
let mockTime = 0;
mockDateNow.mockImplementation(() => mockTime);

global.setMockTime = (time) => {
    mockTime = time;
};

global.advanceMockTime = (milliseconds) => {
    mockTime += milliseconds;
};

// Mock setInterval/clearInterval for timer tests
global.setInterval = jest.fn((callback, interval) => {
    const id = Math.random();
    // Store the callback for manual triggering in tests
    global.setInterval._callbacks = global.setInterval._callbacks || {};
    global.setInterval._callbacks[id] = callback;
    return id;
});

global.clearInterval = jest.fn((id) => {
    if (global.setInterval._callbacks) {
        delete global.setInterval._callbacks[id];
    }
});

// Helper to trigger intervals manually in tests
global.triggerInterval = (id) => {
    if (global.setInterval._callbacks && global.setInterval._callbacks[id]) {
        global.setInterval._callbacks[id]();
    }
};

// Mock setTimeout for animation delays
global.setTimeout = jest.fn((callback, delay) => {
    const id = Math.random();
    global.setTimeout._callbacks = global.setTimeout._callbacks || {};
    global.setTimeout._callbacks[id] = { callback, delay };
    return id;
});

global.clearTimeout = jest.fn();

// Helper to manually trigger timeouts by delay
global.triggerTimeout = (delay) => {
    if (global.setTimeout._callbacks) {
        Object.keys(global.setTimeout._callbacks).forEach(id => {
            const timeoutData = global.setTimeout._callbacks[id];
            if (timeoutData.delay === delay) {
                timeoutData.callback();
                delete global.setTimeout._callbacks[id];
            }
        });
    }
};

// Helper to trigger all timeouts
global.triggerAllTimeouts = () => {
    if (global.setTimeout._callbacks) {
        Object.keys(global.setTimeout._callbacks).forEach(id => {
            const timeoutData = global.setTimeout._callbacks[id];
            timeoutData.callback();
        });
        global.setTimeout._callbacks = {};
    }
};